// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateAuthUser {
  count: Int!
}

type AggregateInvestment {
  count: Int!
}

type AggregateInvestor {
  count: Int!
}

type AuthUser {
  id: ID!
  token: String!
  isActive: Boolean!
}

type AuthUserConnection {
  pageInfo: PageInfo!
  edges: [AuthUserEdge]!
  aggregate: AggregateAuthUser!
}

input AuthUserCreateInput {
  id: ID
  token: String!
  isActive: Boolean!
}

input AuthUserCreateOneInput {
  create: AuthUserCreateInput
  connect: AuthUserWhereUniqueInput
}

type AuthUserEdge {
  node: AuthUser!
  cursor: String!
}

enum AuthUserOrderByInput {
  id_ASC
  id_DESC
  token_ASC
  token_DESC
  isActive_ASC
  isActive_DESC
}

type AuthUserPreviousValues {
  id: ID!
  token: String!
  isActive: Boolean!
}

type AuthUserSubscriptionPayload {
  mutation: MutationType!
  node: AuthUser
  updatedFields: [String!]
  previousValues: AuthUserPreviousValues
}

input AuthUserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AuthUserWhereInput
  AND: [AuthUserSubscriptionWhereInput!]
  OR: [AuthUserSubscriptionWhereInput!]
  NOT: [AuthUserSubscriptionWhereInput!]
}

input AuthUserUpdateDataInput {
  token: String
  isActive: Boolean
}

input AuthUserUpdateInput {
  token: String
  isActive: Boolean
}

input AuthUserUpdateManyMutationInput {
  token: String
  isActive: Boolean
}

input AuthUserUpdateOneRequiredInput {
  create: AuthUserCreateInput
  update: AuthUserUpdateDataInput
  upsert: AuthUserUpsertNestedInput
  connect: AuthUserWhereUniqueInput
}

input AuthUserUpsertNestedInput {
  update: AuthUserUpdateDataInput!
  create: AuthUserCreateInput!
}

input AuthUserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  AND: [AuthUserWhereInput!]
  OR: [AuthUserWhereInput!]
  NOT: [AuthUserWhereInput!]
}

input AuthUserWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Investment {
  id: ID!
  header: String!
  body: String!
}

type InvestmentConnection {
  pageInfo: PageInfo!
  edges: [InvestmentEdge]!
  aggregate: AggregateInvestment!
}

input InvestmentCreateInput {
  id: ID
  header: String!
  body: String!
}

input InvestmentCreateManyInput {
  create: [InvestmentCreateInput!]
  connect: [InvestmentWhereUniqueInput!]
}

type InvestmentEdge {
  node: Investment!
  cursor: String!
}

enum InvestmentOrderByInput {
  id_ASC
  id_DESC
  header_ASC
  header_DESC
  body_ASC
  body_DESC
}

type InvestmentPreviousValues {
  id: ID!
  header: String!
  body: String!
}

input InvestmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  header: String
  header_not: String
  header_in: [String!]
  header_not_in: [String!]
  header_lt: String
  header_lte: String
  header_gt: String
  header_gte: String
  header_contains: String
  header_not_contains: String
  header_starts_with: String
  header_not_starts_with: String
  header_ends_with: String
  header_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [InvestmentScalarWhereInput!]
  OR: [InvestmentScalarWhereInput!]
  NOT: [InvestmentScalarWhereInput!]
}

type InvestmentSubscriptionPayload {
  mutation: MutationType!
  node: Investment
  updatedFields: [String!]
  previousValues: InvestmentPreviousValues
}

input InvestmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InvestmentWhereInput
  AND: [InvestmentSubscriptionWhereInput!]
  OR: [InvestmentSubscriptionWhereInput!]
  NOT: [InvestmentSubscriptionWhereInput!]
}

input InvestmentUpdateDataInput {
  header: String
  body: String
}

input InvestmentUpdateInput {
  header: String
  body: String
}

input InvestmentUpdateManyDataInput {
  header: String
  body: String
}

input InvestmentUpdateManyInput {
  create: [InvestmentCreateInput!]
  update: [InvestmentUpdateWithWhereUniqueNestedInput!]
  upsert: [InvestmentUpsertWithWhereUniqueNestedInput!]
  delete: [InvestmentWhereUniqueInput!]
  connect: [InvestmentWhereUniqueInput!]
  set: [InvestmentWhereUniqueInput!]
  disconnect: [InvestmentWhereUniqueInput!]
  deleteMany: [InvestmentScalarWhereInput!]
  updateMany: [InvestmentUpdateManyWithWhereNestedInput!]
}

input InvestmentUpdateManyMutationInput {
  header: String
  body: String
}

input InvestmentUpdateManyWithWhereNestedInput {
  where: InvestmentScalarWhereInput!
  data: InvestmentUpdateManyDataInput!
}

input InvestmentUpdateWithWhereUniqueNestedInput {
  where: InvestmentWhereUniqueInput!
  data: InvestmentUpdateDataInput!
}

input InvestmentUpsertWithWhereUniqueNestedInput {
  where: InvestmentWhereUniqueInput!
  update: InvestmentUpdateDataInput!
  create: InvestmentCreateInput!
}

input InvestmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  header: String
  header_not: String
  header_in: [String!]
  header_not_in: [String!]
  header_lt: String
  header_lte: String
  header_gt: String
  header_gte: String
  header_contains: String
  header_not_contains: String
  header_starts_with: String
  header_not_starts_with: String
  header_ends_with: String
  header_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [InvestmentWhereInput!]
  OR: [InvestmentWhereInput!]
  NOT: [InvestmentWhereInput!]
}

input InvestmentWhereUniqueInput {
  id: ID
}

type Investor {
  id: ID!
  auth: AuthUser!
  fistName: String!
  lastName: String!
  investments(where: InvestmentWhereInput, orderBy: InvestmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Investment!]
}

type InvestorConnection {
  pageInfo: PageInfo!
  edges: [InvestorEdge]!
  aggregate: AggregateInvestor!
}

input InvestorCreateInput {
  id: ID
  auth: AuthUserCreateOneInput!
  fistName: String!
  lastName: String!
  investments: InvestmentCreateManyInput
}

type InvestorEdge {
  node: Investor!
  cursor: String!
}

enum InvestorOrderByInput {
  id_ASC
  id_DESC
  fistName_ASC
  fistName_DESC
  lastName_ASC
  lastName_DESC
}

type InvestorPreviousValues {
  id: ID!
  fistName: String!
  lastName: String!
}

type InvestorSubscriptionPayload {
  mutation: MutationType!
  node: Investor
  updatedFields: [String!]
  previousValues: InvestorPreviousValues
}

input InvestorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InvestorWhereInput
  AND: [InvestorSubscriptionWhereInput!]
  OR: [InvestorSubscriptionWhereInput!]
  NOT: [InvestorSubscriptionWhereInput!]
}

input InvestorUpdateInput {
  auth: AuthUserUpdateOneRequiredInput
  fistName: String
  lastName: String
  investments: InvestmentUpdateManyInput
}

input InvestorUpdateManyMutationInput {
  fistName: String
  lastName: String
}

input InvestorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  auth: AuthUserWhereInput
  fistName: String
  fistName_not: String
  fistName_in: [String!]
  fistName_not_in: [String!]
  fistName_lt: String
  fistName_lte: String
  fistName_gt: String
  fistName_gte: String
  fistName_contains: String
  fistName_not_contains: String
  fistName_starts_with: String
  fistName_not_starts_with: String
  fistName_ends_with: String
  fistName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  investments_every: InvestmentWhereInput
  investments_some: InvestmentWhereInput
  investments_none: InvestmentWhereInput
  AND: [InvestorWhereInput!]
  OR: [InvestorWhereInput!]
  NOT: [InvestorWhereInput!]
}

input InvestorWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAuthUser(data: AuthUserCreateInput!): AuthUser!
  updateAuthUser(data: AuthUserUpdateInput!, where: AuthUserWhereUniqueInput!): AuthUser
  updateManyAuthUsers(data: AuthUserUpdateManyMutationInput!, where: AuthUserWhereInput): BatchPayload!
  upsertAuthUser(where: AuthUserWhereUniqueInput!, create: AuthUserCreateInput!, update: AuthUserUpdateInput!): AuthUser!
  deleteAuthUser(where: AuthUserWhereUniqueInput!): AuthUser
  deleteManyAuthUsers(where: AuthUserWhereInput): BatchPayload!
  createInvestment(data: InvestmentCreateInput!): Investment!
  updateInvestment(data: InvestmentUpdateInput!, where: InvestmentWhereUniqueInput!): Investment
  updateManyInvestments(data: InvestmentUpdateManyMutationInput!, where: InvestmentWhereInput): BatchPayload!
  upsertInvestment(where: InvestmentWhereUniqueInput!, create: InvestmentCreateInput!, update: InvestmentUpdateInput!): Investment!
  deleteInvestment(where: InvestmentWhereUniqueInput!): Investment
  deleteManyInvestments(where: InvestmentWhereInput): BatchPayload!
  createInvestor(data: InvestorCreateInput!): Investor!
  updateInvestor(data: InvestorUpdateInput!, where: InvestorWhereUniqueInput!): Investor
  updateManyInvestors(data: InvestorUpdateManyMutationInput!, where: InvestorWhereInput): BatchPayload!
  upsertInvestor(where: InvestorWhereUniqueInput!, create: InvestorCreateInput!, update: InvestorUpdateInput!): Investor!
  deleteInvestor(where: InvestorWhereUniqueInput!): Investor
  deleteManyInvestors(where: InvestorWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  authUser(where: AuthUserWhereUniqueInput!): AuthUser
  authUsers(where: AuthUserWhereInput, orderBy: AuthUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AuthUser]!
  authUsersConnection(where: AuthUserWhereInput, orderBy: AuthUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AuthUserConnection!
  investment(where: InvestmentWhereUniqueInput!): Investment
  investments(where: InvestmentWhereInput, orderBy: InvestmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Investment]!
  investmentsConnection(where: InvestmentWhereInput, orderBy: InvestmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InvestmentConnection!
  investor(where: InvestorWhereUniqueInput!): Investor
  investors(where: InvestorWhereInput, orderBy: InvestorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Investor]!
  investorsConnection(where: InvestorWhereInput, orderBy: InvestorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InvestorConnection!
  node(id: ID!): Node
}

type Subscription {
  authUser(where: AuthUserSubscriptionWhereInput): AuthUserSubscriptionPayload
  investment(where: InvestmentSubscriptionWhereInput): InvestmentSubscriptionPayload
  investor(where: InvestorSubscriptionWhereInput): InvestorSubscriptionPayload
}
`